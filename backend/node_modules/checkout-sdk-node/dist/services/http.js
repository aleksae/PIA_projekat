"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.put = exports.post = exports.patch = exports.get = exports.default = exports.createAccessToken = exports._delete = void 0;
var _config = require("../config");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
const pjson = require('../../package.json');
const get = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (fetch, path, config, auth) {
    return http(fetch, 'get', path, config, auth);
  });
  return function get(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();
exports.get = get;
const post = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(function* (fetch, path, config, auth, request, idempotencyKey) {
    return http(fetch, 'post', path, config, auth, request, idempotencyKey);
  });
  return function post(_x5, _x6, _x7, _x8, _x9, _x10) {
    return _ref2.apply(this, arguments);
  };
}();
exports.post = post;
const patch = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator(function* (fetch, path, config, auth, request) {
    return http(fetch, 'patch', path, config, auth, request);
  });
  return function patch(_x11, _x12, _x13, _x14, _x15) {
    return _ref3.apply(this, arguments);
  };
}();
exports.patch = patch;
const put = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(function* (fetch, path, config, auth, request) {
    return http(fetch, 'put', path, config, auth, request);
  });
  return function put(_x16, _x17, _x18, _x19, _x20) {
    return _ref4.apply(this, arguments);
  };
}();
exports.put = put;
const _delete = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator(function* (fetch, path, config, auth) {
    return http(fetch, 'delete', path, config, auth);
  });
  return function _delete(_x21, _x22, _x23, _x24) {
    return _ref5.apply(this, arguments);
  };
}();
exports._delete = _delete;
const createAccessToken = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator(function* (config, fetch, body) {
    const requestBody = body || {
      grant_type: 'client_credentials',
      client_id: config.client,
      client_secret: config.secret,
      scope: config.scope.join(' ')
    };
    const access = yield fetch(config.host.includes('sandbox') ? _config.SANDBOX_ACCESS_URL : _config.LIVE_ACCESS_URL, {
      method: 'post',
      timeout: config.timeout,
      agent: config.agent,
      body: new URLSearchParams(requestBody),
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        Accept: 'application/json'
      }
    });
    if (!access.ok) {
      const json = bodyParser(access);
      throw {
        status: access.status,
        json
      };
    }
    return access.text().then(text => {
      const data = text ? JSON.parse(text) : {};
      return {
        status: access.status,
        json: data
      };
    });
  });
  return function createAccessToken(_x25, _x26, _x27) {
    return _ref6.apply(this, arguments);
  };
}();

// eslint-disable-next-line consistent-return,default-param-last
exports.createAccessToken = createAccessToken;
const http = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator(function* (fetch, method, path, config, auth, request, idempotencyKey) {
    let authHeader = null;
    if (auth) {
      authHeader = auth;
    } else if (config.client) {
      // TODO Refactor OAuth credentials request

      // For NAS
      // If an access tokens exists and it's not expired re-use it
      if (config.access && !isTokenExpired(config.access.expires, new Date())) {
        authHeader = `${config.access.type} ${config.access.token}`;
      } else {
        const access = yield createAccessToken(config, fetch);
        authHeader = `${access.json.token_type} ${access.json.access_token}`;

        // eslint-disable-next-line no-param-reassign
        config.access = {
          token: access.json.access_token,
          type: access.json.token_type,
          scope: access.json.scope,
          expires: new Date(new Date().getTime() + access.json.expires_in)
        };
      }
    }
    const headers = getRequestHeaders(config, request, authHeader, idempotencyKey);
    const response = yield fetch(path, {
      method,
      timeout: config.timeout,
      agent: config.agent,
      body: config.formData ? request : JSON.stringify(request),
      headers
    });
    if (!response.ok) {
      const json = bodyParser(response);
      throw {
        status: response.status,
        json
      };
    }
    return buildResponse(config, response);
  });
  return function http(_x28, _x29, _x30, _x31, _x32, _x33, _x34) {
    return _ref7.apply(this, arguments);
  };
}();
function buildResponse(config, response) {
  if (config.csv) {
    return buildCsvResponse(response);
  }
  return buildJsonResponse(response);
}
function buildCsvResponse(_x35) {
  return _buildCsvResponse.apply(this, arguments);
}
function _buildCsvResponse() {
  _buildCsvResponse = _asyncToGenerator(function* (response) {
    const txt = yield response.text();
    const csv = Buffer.from(txt);
    return {
      status: response.status,
      csv
    };
  });
  return _buildCsvResponse.apply(this, arguments);
}
function buildJsonResponse(response) {
  return response.text().then(text => {
    const data = text ? JSON.parse(text) : {};
    const headers = getResponseHeaders(response);
    return {
      status: response.status,
      json: data,
      headers
    };
  });
}
function getRequestHeaders(config, request, authHeader, idempotencyKey) {
  let headers;

  // eslint-disable-next-line prefer-const
  headers = _objectSpread(_objectSpread({}, config.headers), {}, {
    Authorization: authHeader,
    'Cache-Control': 'no-cache',
    pragma: 'no-cache',
    'user-agent': `checkout-sdk-node/${pjson.version}`
  });
  if (request && request.headers) {
    headers = _objectSpread(_objectSpread({}, headers), request.headers);
  }
  if (!config.formData) {
    headers['Content-Type'] = config.csv ? 'text/csv' : 'application/json';
  }
  if (idempotencyKey !== undefined) {
    headers['Cko-Idempotency-Key'] = idempotencyKey;
  }
  return headers;
}
function getResponseHeaders(response) {
  // Return CKO response headers when available

  if (_config.REQUEST_ID_HEADER in response.headers.raw()) {
    const requestId = response.headers.raw()[_config.REQUEST_ID_HEADER] || response.headers.raw()['request-id'];
    const version = response.headers.raw()[_config.API_VERSION_HEADER] || response.headers.raw().version;
    return {
      'cko-request-id': requestId ? requestId[0] : '',
      'cko-version': version ? version[0] : ''
    };
  }
  return {};
}

// For 'no body' response, replace with empty object
const bodyParser = rsp => rsp.text().then(text => text ? JSON.parse(text) : {});
const isTokenExpired = (tokenExpiry, currentTimestamp) => tokenExpiry < currentTimestamp;
var _default = createAccessToken;
exports.default = _default;
//# sourceMappingURL=http.js.map